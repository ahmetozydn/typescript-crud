import { IRepository } from '../Interfaces/IRepository'
import { IPost } from '../Interfaces/IPost'
import { IResult } from '../Interfaces/IResult'
import { injectable } from 'inversify'
import { Post } from '../Models/posts'
import "reflect-metadata";
import { Document, Types } from 'mongoose'

// business layer
@injectable() // decorator
class PostService implements IRepository {

    //get all posts
    async getPosts() { // asynchronous func.
        try {
            const posts = await Post.find({})
            return posts
        } catch (error) {
            console.log(error)
        }
    }

    //get a single post
    async getPost(id: string) {
        try {
            const post = await Post.findById({ _id: id })
            if (!post) {
                return 'post not available'
            }
            return post
        } catch (error) {
            console.log(error)
        }
    }
    //create a post
    async createPost(data: any) {
        try {
            const newPost = await Post.create(data)
            return newPost
        } catch (error) {
            console.log(error)
        }
    }

    //update a post
    async updatePost(id: string, data: any) {
        try {
            //pass the id of the object you want to update
            //data is for the new body you are updating the old one with
            //new:true, so the dats being returned, is the update one
            const posts = await Post.findByIdAndUpdate({ _id: id }, data, { new: true })
            if (!posts) {
                return "post not available"
            }
            return posts
        } catch (error) {
            console.log(error)
        }
    }

    //delete a post by using the find by id and delete 
    async deletePost(id: string) {
        try {
            const post = await Post.findByIdAndDelete(id)
            if (!post) {
                return 'post not available'
            }
        } catch (error) {
            console.log(error)
        }
    }

    async patchUpdate(id: string, data: any) {
        try {
            const updatedOne = await Post.updateOne(
                { _id: id },
                { $set: data }
            );
            return updatedOne
        } catch (err) {
            console.log(err);
        }

    }

    async getChunk(queryPool: {
        sortType: string,
        pageIndex: number,
        orderBy: 1 | -1,
        filter: {
            likes: {
                $gte: number;
                $lte: number;
            };
        }
    }, limit: number = 5) {
        //const pagination = new Pagination(queryPool.pageIndex, limit); // pass page-index and limit

        let items: (Document<unknown, any, IPost> & IPost & {
            _id: Types.ObjectId;
        })[]

        console.log(queryPool.filter.likes);

        items = await Post.find(queryPool.filter)
            .sort({ [queryPool.sortType]: queryPool.orderBy }) // id is automatically generated by mongodb so posts requested according to createdAt
            .skip((queryPool.pageIndex - 1) * limit) // first post, get posts by index
            .limit(limit) // last post

        const result: IResult = {
            total: await Post.countDocuments(),
            limit: limit,
            posts: items
        }
        return result
    }

    async search(q: string, queryPool: {
        sortType: string,
        pageIndex: number,
        orderBy: 1 | -1
    }, limit: number = 2) {
        try {
            console.log(q)

            // that's a exact string match solution, mongoDB doesn't support partial match search but can be found solutions...
            const answer = await Post.find({ $text: { $search: q, $caseSensitive: true } })
                 .sort({[queryPool.sortType]: queryPool.orderBy })
                .skip((queryPool.pageIndex - 1) * limit)
                .limit(limit)

            const result: IResult = {
                total: answer.length,
                limit: limit,
                posts: answer
            }
            return result
        } catch (error) { console.log(error) }
    }
}

export { PostService } 
