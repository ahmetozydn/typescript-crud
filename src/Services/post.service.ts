import { IRepository } from '../Interfaces/IRepository'
import { IPost } from '../Interfaces/IPost'
import { IResult } from '../Interfaces/IResult'
import { injectable } from 'inversify'
import { Post } from '../Models/posts'
import "reflect-metadata";
import { Pagination } from './pagination';
import { SORT_OPT } from "../DI/types" // used in inversify
import { Document, Types } from 'mongoose'

// business layer
@injectable() // decorator
class PostService implements IRepository {

    //get all posts
    async getPosts() { // asynchronous func.
        try {
            const posts = await Post.find({})
            return posts
        } catch (error) {
            console.log(error)
        }
    }

    //get a single post
    async getPost(id: string) {
        try {
            const post = await Post.findById({ _id: id })
            if (!post) {
                return 'post not available'
            }
            return post
        } catch (error) {
            console.log(error)
        }
    }
    //create a post
    async createPost(data: any) {
        try {
            const newPost = await Post.create(data)
            return newPost
        } catch (error) {
            console.log(error)
        }
    }

    //update a post
    async updatePost(id: string, data: any) {
        try {
            //pass the id of the object you want to update
            //data is for the new body you are updating the old one with
            //new:true, so the dats being returned, is the update one
            const posts = await Post.findByIdAndUpdate({ _id: id }, data, { new: true })
            if (!posts) {
                return "post not available"
            }
            return posts
        } catch (error) {
            console.log(error)
        }
    }

    //delete a post by using the find by id and delete 
    async deletePost(id: string) {
        try {
            const post = await Post.findByIdAndDelete(id)
            if (!post) {
                return 'post not available'
            }
        } catch (error) {
            console.log(error)
        }
    }
    
    async patchUpdate(id: string, data: any) {
        try {
            const updatedOne = await Post.updateOne(
                { _id: id },
                { $set: data }
            );
            return updatedOne
        } catch (err) {
            console.log(err);
        }

    }

    async getChunk(queryPool: {
        sortType: string,
        pageIndex: number,
        orderBy: 1 | -1
    }, limit: number = 5) {
        //const pagination = new Pagination(queryPool.pageIndex, limit); // pass page-index and limit

        let items: (Document<unknown, any, IPost> & IPost & {
            _id: Types.ObjectId;
        })[]

        items = await Post.find()
            .sort({ [queryPool.sortType]: queryPool.orderBy }) // id is automatically generated by mongodb so posts requested according to createdAt
            .skip((queryPool.pageIndex - 1) * limit) // first post, get posts by index
            .limit(limit); // last post

        const result: IResult = {
            total: await Post.countDocuments(),
            limit: limit,
            posts: items
        }
        return result


        /*      const isParamValid = await pagination.isParamValid() // check if the page-index is defined or invalid
     
             if (isParamValid == "undefined") {
                 return 'Undefined page number'
             } else if (isParamValid == "invalid") {
                 return 'Invalid page number requested.'
             }
             const result = await pagination.getPage();
             
             return result */
    }
    async sort(value: string) {

        /*         if(value == SORT_OPT.author){
                    const items = await Post.find()
                    .sort({ author: -1 })
                    .skip((this.pageIndex - 1) * this.limit)
                    .limit(this.limit);
                }
                if(value == SORT_OPT.title){
                    
                }
                if(value == SORT_OPT.description){
        
                }    */
    }
}

export { PostService } 
